1.操作系统的概述【OK】

一般计算机的启动过程？
答：
（1）由ROM程序对硬件进行检测。
（2）由ROM中的启动程序将磁盘上的引导块读入内存。
（3）由引导块将OS的内核调入内存。
（4）执行OS内核程序，对OS自身进行初始化。
（5）加载外核处理程序，给出提示，等待用户操作。

给出系统总体上的中断处理过程?
答：
CPU每执行完一条指令就去扫描中断寄存器，检查是否有中断发生，若没有中断就继续执行下条指令；
若有中断发生就转去执行相应的中断处理程序。
中断处理过程可粗略的分为以下四个过程：
① 保护当前正在运行程序的现场；
② 分析是何种中断，以便转去执行相应的中断处理程序；
③ 执行相应的中断处理程序；
④ 恢复被中断程序的现场


2.进程与线程【OK】

Windows这样的多任务系统和Unix这样的多进程系统在调度上有何不同？
答：
从调度上讲，在Windows这样的多任务系统中，当前执行哪个任务是由用户决定的，是用户可控制的；
而在Unix这样的多进程系统中，当前运行哪个进程是由内部的调度算法决定，是对用户透明的，用户是不可直接控制的。

进程和线程的主要区别是什么？
答：
进程是系统资源分配的独立单位，而线程是可调度运行的独立单位。

作业调度算法有哪些？
答
1、先来先服务算法；
2、短作业优先算法；
3、最高响应比作业优先算法；
4、资源搭配算法；
5、多队列循环算法



3.互斥和死锁【OK】

何为死锁？产生死锁的原因和必要条件是什么？
答：
死锁是指多个进程因竞争资源而造成的一种僵持状态。若无外力作用，这些进程都将永远处于阻塞状态，不能再运行下去。
产生死锁的原因有：资源不足、进程推进次序不当。
产生死锁的必要条件有：互斥条件、请求和保持条件、环路等待条件、不可被剥夺条件

比较三种解决死锁的方法?
答：
预防死锁方法，主要是破坏产生死锁的必要条件。最容易实现的，但系统资源利用率较低。
避免死锁方法，银行家算法。实现困难，但资源利用率最高。
检测死锁方法，定期运行该算法对系统的状态进行检测，发现死锁便予以解除。最难实现，资源利用率较高。

预防死锁方法的具体实现？
答：
1.摈弃请求和保持条件。采用静态分配方案，一次性地分配给进程所请求的全部资源。进程运行过程中不可再请求新资源。
2.摈弃环路等待条件。采用动态分配方案，要求进程请求资源时，按资源序号递增（或递减）顺序提出。
2.摈弃不剥夺条件。采用动态分配方案，进程运行中可以请求新资源。若进程请求资源不能满足时，就应使其释放已占有的资源。利用Spooling系统将独享设备改造成共享设备。


简述死锁的防止与死锁的避免的区别？
答：
死锁的防止是预分配资源。静态分配
死锁的避免是当系统安全时才分配资源。银行家算法。



4.文件系统【OK】

简述"删除文件"操作的系统处理过程？
答：
用户向系统提出删除一个文件的要求，系统执行时把指定文件的名字从目录和索引表中除去，
并收回它所占用的存储区域，但删除一个文件前应先关闭该文件。


5.输入输出
答：
