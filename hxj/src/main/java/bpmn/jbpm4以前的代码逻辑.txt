一.以前版本的jbpm的的代码逻辑：版本是4和更早之前的版本。
    0.1 专业特色：基于图的语言。可以实现等待状态的持久化。一般的语言，比如Java就不支持。
             它是一种面向图形编程--GOP。对图进行解释执行。它的实现由OOP--面向对象实现。
             GOP是一种设计模式。流程引擎也叫做状态机。它是一种微内核结构。jBpm3之前采用了Activity Diagram的模型，jbpmn7.15采用BPMN建立模型。而osworkflow则是FSM的模型。
    0.2 实现原理：
        参考URL：https://blog.csdn.net/tansdale/article/details/1092337
        主要概念：
            图=node节点+transition弧
            流程定义：面向图，一个节点一个类型，代表不同的执行功能。比如start state代表开始节点一样
            Token：是一个运行标记。，代表了流程定义中的一个执行。它是运行时概念。维护指向图节点的指针。
                   需要信号signal让流程执行。通过弧transition离开当前节点到下一个节点
            流程实例：一个流程实例就是流程定义的一次执行。创建流程实例时，主路径Root token被创建。指向开始状态
            ACTION：token进入node，执行node--代表图的执行行为。token触发事件，让行为action被执行。本质是一段Java代码
                    有一种事件监听器的感觉。
    0.3 jbpm引擎内核设计思想和架构：
            参考URL：https://www.cnblogs.com/haore147/p/5213655.html
            引擎关注的问题：解决一个过程运行问题，按秩序的从一个节点到另一个节点的执行。
                          引擎的抽象和引擎的应用是两个纬度。工作流程引擎自身就是基于模型的组件。

            流程引擎组合：
                内核：仅包含最基本的对象和服务，以及用于解决流程运行问题的调度机制和执行机制。
                     职责是：确保流程按照既有的定义，从一个节点运行到另一个节点，并正确执行当前节点
                外围封装：主要的5个。
                    状态存储：一个状态就是一个节点。
                    事件处理：token到达，触发监听等
                    组织适配：
                    时间调度：定时器
                    消息服务：执行任务句柄
            关注的4个主要问题：
               1.模型与定义对象：流程定义问题。----使用一套定义对象，来描述所定义的流程，并且映射处一种模型。用一堆自定义概念描述图。
                    形式化描述一个流程：
                        解决：使用BPMN等建模语言描述。
                    解析流程定义：
                        解决：有自己的新实话描述语言，比如xml。有对象集合可以反映流程的定义模型和结果，一般叫做定义对象,比如节点和弧
                    抽象节点(Node)和转移(Transition)：
                        解决：使用抽象类描述，比如节点的类型，进入和离去的弧。节点如何扩展。自定义节点方法：1.继承Node;2.重写读写xml的read和write方法;3.重写执行方法execute。

               2.调度机制与算法：关键！提供什么机制来确保流程能够处理复杂的图结构，确保流程从一个节点运行到另一个节点。
                             有多种机制，于所依赖模型有关。一般采用Petri Net调度机制，具体采用token来调度。jbpm在token基础上做了一点处理
                             采用Token来表示当前实例运行的位置，Token的推进表示流程的推进。触发流程往下运行的操作有如下：（原理都是当前token的signal操作）
                                1.强制执行ProcessInstance的signal操作
                                2.执行TaskInstance的end操作
                             Token的Signal操作表示：实例需要离开当前token所在的节点，转移到下一个节点上。Token轨迹：节点1-》有向弧transition-》节点2
                                对应源码逻辑：开始：执行上下文和有向弧作为参数，传递到节点的leave方法中。token存在库中，上下文存在有向弧中
                                            继续：执行上下文建立一个：弧1-》节点-》弧2的图，通过弧2的take方法执行。
                                            继续：上下文作为参数，被节点的enter方法调用
                                            结束：上下文获取token赋值到最新位置。

               3.执行机制与状态：提供什么机制，来决定是否执行此节点，并如何执行此节点的问题，并维持节点状态生命周期。
                             提供runtime envrioment来执行节点。具体是通过《活动实例状态》的约束和变迁进行处理。
                             必要准备：节点多，执行方式不同；节点有生命周期，对应不同的状态。jbpm没有突出节点生命周期，而是在UserTask等Event中体现
                                      jbpm没有NodeInstance；Event围绕Token转移设置
                             分支处理：采用subToken。

               4.实例对象与执行环境：需要一整套对象，描述流程运行的状态和结果。processInstance保存运行环境和数据。还有执行上下文。
    0.4 工作流文档整理：参考URL：https://www.cnblogs.com/haore147/p/5213679.html

    1.目录结构：
        stateInterface目录：
            里面是各种请求的接口，接口里面是静态常量，用作路由选择的枚举值
        action目录：
            各种actionHandler，从决策中得到处理信息。然后进行对应的决策处理，是独立的service类
        decision目录：
            各种DecisionHandler，从上下文获取变量，然后决定路由方式，是独立的service类
        task目录：
            各种AssignmentHandler，从上下文获取变量，然后声明并处理分配的任务，是独立的service类
        jpdl目录:
            ?gpd.xml:
               流程图的xml文件，各种节点的描述，主要的标签有<node>,<transition>.最终描述的是流程图中的矢量线
            ?processdefinition.xml:
               流程图的定义xml文件，有各种节点。其中任务节点有变量传递，分配者的句柄处理类方法，还有线上的业务逻辑。
               网关有自己的分叉处理路由，决策有自己的处理句柄类
            ?processimage.png:
                流程图片，详细决定流程的可视化情况
    2.测试代码的逻辑：
        2.1 部署流程定义：获取流程定义xml文件的流对象
        2.2 创建流程实例：使用流对象创建流程对象，获取Join节点的对象。然后通过上下文设置流程变量的各个执行用户。然后发送信号启动流程
        2.3 申请人写请求：从任务管理器获取所有任务，中途可能需要获取任务上下文来设置流程变量，然开始写任务
        2.4 主管决策：从任务管理器获取任务集合，找到指定的任务类型，根据决策结果参数来决定返回路由
        2.5 老板决策：从任务管理器获取任务集合，找到指定的任务类型，根据决策结果参数来决定返回路由
        2.6 最后检查任务：从任务管理器获取任务集合，然后逐个任务进行日志或者其他处理
    3.工作流引擎的5部分：--每个服务对应一张表
        3.1 部署流程：
                创建流程引擎
                *创建服务--资源服务
                *部署流程--使用xml文件
        3.2 创建流程实例
                创建流程引擎：
                创建服务--执行服务
                *创建流程实例--ID
        3.3 获取当前活动
                创建流程引擎：
                创建服务--执行服务
                *查询流程实例当前所在节点
        3.4 获取特定用户的任务
                创建流程引擎：
                *创建服务--任务服务
                *查询用户任务--个人任务
        3.5 完成任务
                创建流程引擎：
                创建服务--任务服务
                *完成任务--任务ID



