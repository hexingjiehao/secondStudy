1.学习《代码整洁之道》一书
    1.TPM概念：Total Productive Maintenance = 全员生产维护。它是一种质量保证手段。
              核心概念是5S原则：
                    整理：分类排序，命名标识很重要。
                    整顿：系统化，代码在它该在的地方，每个功能代码在它的指定层次位置
                    清楚：删除无效注释
                    清洁：标准化，相似的功能，使用相同的编写规范
                    身美：个人开发时随时保持代码整洁

    第1章.整洁代码
        答：模糊需求存在一日，代码永存不灭
            稍后等于永不
            混乱的代价：混乱增加，生产力下降，增加人手，期望提升生产力，新人惧怕，旧人压力山大，更多混乱。最终走向0生产力
            新设计不代表新开始，从问题源头解决才是正途
            坚守自己的代码底线，不做混乱的产品需求，即使产品不喜欢。
            混乱压力来源于期限，但是解决期限和混乱的治本的方法是代码整洁。忙则乱，乱则错，错则悔。核心是保持有计划的忙碌而不慌乱。
            整洁代码：干净的只做一件事。可读，小而美。核心是抽象，抽象是需要自己去悟！！！
            编辑器回放：读的时间是写的时间的10倍

    第2章.有意义的命名：
        答：1.名副其实。如果名称需要注释来补充，就不算名副其实。
                代码不能出现模糊度。让每段代码看起来有意义。
                    比如：这个list是什么类型的东西？ 改进措施：修改名称为有意义的名字
                          它的0下标的意义是什么？            修改有有名字的常量
                          这个魔数4是什么含义？              修改为有名字的常量
                          我怎么使用方法返回值？             修改返回值名字
                                                           将int[]数组修改为对象，if判断修改为对象方法
                案例举例：混乱的代码：
                    public List<int[]> getThem(){
                        List<int[]> list1=new ArrayList<int[]>();
                        for(int[] x:theList){
                            if(x[0]==4){
                                list1.add(x);
                            }
                        }
                        return list1;
                    }
                修改后的好代码：
                    public List<Cell> getFlaggedCells(){
                        List<Cell> flaggedCells=new ArrayList<Cell>();
                        for(Cell cell:gameBoard){
                            if(cell.isFlagged){
                                flaggedCells.add(cell);
                            }
                        }
                        return flaggedCells;
                    }
                总结：1.改变量名字；2.改变量类型；3.将if判断修改为对象方法
            2.避免误导：
                不要留下错误线索注释，或者遗留与本意相反的名字
                变量命名不要用类型名。比如list集合的命名后缀不要用List,而是应该用s【非常重要！！！这是自己之前代码常犯的错误】
                    accountList: 错误范例。
                    accounts, accountGroup, bunchOfAccounts: 正常范例
                不要用小写字母l和大写字母O做变量名，因为他们看起来像数字1和0
            3.做有意义的区分：
                1.以数字系列命名毫无意义：因为你完全无法区分a1,a2,a3的区分是什么
                2.废话是另一种没意义的区分：举例如下
                        Product 和ProductInfo 和ProductData 没意义区别
                        a 和an 和the 没意义区别
                        缺少约定： moneyAmount 和money没区别
                                  customerInfo 和customer没区别
                                  accountData 和account没区别
                                  theMessage 和message没区别
                                  Customer 和CustomerObject没区别
                        NameString 不比Name命名好，难道Name会是一个浮点数吗？
                3.不要在变量中命名Variable,不要在表命名中Table,因为他们是关键字
                核心是做到：真正有意义的不同命名区分。
            4.使用读的出来的名称：
                使用英文单词，而不是自造词，或者缩写词。这样不利于交流
                案例：
                    反例：genymdhms 表示生成时间戳
                    正例：generationTimestamp 表示生成时间戳
            5.使用可搜索的名称：
                长名胜过短名，因为它有意义而且能够快速找到，虽然拉长了代码量
                案例： s,t,j 比不过realTaskDays的命名，因为后者方便搜索
            6.编码使用编码：
                不要把类型和作用域放入命名中。它是多余的负担
                反例：accountsList，List没必要再放入名称中
                匈牙利语标记法（HN）：
                    背景：之前编译器不做类型检查，变量命名必须附加类型说明
                    现在：编辑器进化，java强类型，已经不需要这样命名了。它徒增阅读难度
                    反例：phoneNumber ,phoneString
                成员前缀：
                    不要使用，人们习惯忽略前缀，它是旧时代的产物
                接口和实现的使用：
                    案例：接口/实现类：IShapeFactory / ShapeFactory
                          I前缀被接口滥用编码了。我们不想让客户知道它是接口，而是一个工厂
                          作者的建议：接口/实现类： ShapeFactory / CShapeFactory或者ShapeImpl
                    总之，就是不要对接口编码, 宁可Impl实现类后缀编码，也不是要I接口前缀编码
            7.避免思维映射：
                不要把你熟悉的命名缩写当做别人也知道这个命名缩写，因为你们两个对于同一个缩写可能有不同的理解
                一定要明确含义
            8.类名
                应该是名词，不应该是动词。不应该区分度差，具象化要高才行
                案例：好的命名：Customer, WikiPage,Account,AddressParser
                      坏的命名：
                         Manager： 命名不够具象化【非常重要，目前公司的命名就是不符合规范的！！！】
                         Processor： 命名不够具象化
                         Data: 区分度较差
                         Info: 区分度较差
            9.方法名：
                使用动词或者动词短语：比如postPayment,deletePage,save, getXXX(),setXXX(),isXXX()
                带参构造器：使用静态工厂方法，对应私有构造器private修饰
                    反例：Person a=new Person(23)
                    正例：Person a=Person.FromNumber(23)
            10.别扮演可爱：
                别用whack()来表示kill(),别用eatMyShorts()表示abort()。不要用典故命名，别人可能不知道这个典故
            11.每个概念对应一个词
                功能: 它是一个控制器类。那么命名就都用controller，而不应该有的用controller,有的用manager,还有的用driver.
                     命名风格要统一，根据不同功能层级使用不同的后缀等
            12.别用双关语：
                平装书模式：大众化写清楚
                学院派模式：挖地三尺才明白含义
                举例：addxxx()方法：比如现在表示1个参数放入到集合中；那么另外的功能，将a+b=c也用addXXX()方法就不合适，它导致双关了
            13.使用解决方案领域名称【对于代码协作者】
                你的代码只有程序员阅读，就不要使用业务领域名称。而是计算机灵越名称
                比如GSP是医药业务领域的校验，那么在代码中校验方法就不要写成gsp(),而应该写成validate(), 因为别人会跑去问客户，gsp是啥，他本质是一个校验方法
            14.使用问题领域名称
                这是退而求其次，找不到合适的计算术语的时候，可以去请教业务专家。如果某段代码核心是业务领域，那么就使用业务领域命名。
            15.添加有意义的语境：
                 场景：1个方法中有多个变量，这些变量在算法中流转。
                      初次看到不知其意，将其封装为对象中变量，提供有意义的函数，命名空间，让这些变量变得容易理解
                 比如：firstName我们知道是名字，但是不知道具体是什么名字
                       addrFirstName我们知道是地址的名字，通过增加前后缀，我们知道了这个变量的语境，虽然这是最不推荐的方法
                       我们推荐使用封装一个Address对象，封装一个firstName来表示地址名称。这些提供语境更容易理解，并且易于后续拆分
            16.不要添加没用的语境：
                不要增加无用的前缀。
                短名称足够清楚，有明确的语境，就要比长名称好。别给名称增加不必要的语境
                比如：MAC地址，端口地址，Web地址的命名
                    反例：MacAddress, PortAddress,WebAddress。他们增加了不必要的语境，也就是不必要的后缀。不增加后缀也能过清楚的明白含义
                    正例：Mac,URI,PostalAddress
                总结：精确命名才是重点

    第3章.函数：
    第4章.注释：
    第5章.格式：
    第6章.对象和数据结构
    第7章.错误处理：
    第8章.边界：
    第9章.单元测试：
    第10章.类：
    第11章.系统：
    第12章.迭进：
    第13章.并发编程：
    第14章.逐步改进：
    第15章.JUnit内幕：
    第16章.重构SerialDate:
    第17章.味道和启发：
2.开始学习书本章节：
    附录：并发编程
        1.客户端/服务器的例子
        2.执行的可能路径
        3.了解类库
        4.方法之间的依赖可能破坏并发代码
        5.提升吞吐量
        6.死锁
        7.测试多线程代码
        8.测试线程代码的工具支持

