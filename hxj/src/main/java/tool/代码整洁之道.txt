1.学习《代码整洁之道》一书
    1.TPM概念：Total Productive Maintenance = 全员生产维护。它是一种质量保证手段。
              核心概念是5S原则：
                    整理：分类排序，命名标识很重要。
                    整顿：系统化，代码在它该在的地方，每个功能代码在它的指定层次位置
                    清楚：删除无效注释
                    清洁：标准化，相似的功能，使用相同的编写规范
                    身美：个人开发时随时保持代码整洁

    第1章.整洁代码
        答：模糊需求存在一日，代码永存不灭
            稍后等于永不
            混乱的代价：混乱增加，生产力下降，增加人手，期望提升生产力，新人惧怕，旧人压力山大，更多混乱。最终走向0生产力
            新设计不代表新开始，从问题源头解决才是正途
            坚守自己的代码底线，不做混乱的产品需求，即使产品不喜欢。
            混乱压力来源于期限，但是解决期限和混乱的治本的方法是代码整洁。忙则乱，乱则错，错则悔。核心是保持有计划的忙碌而不慌乱。
            整洁代码：干净的只做一件事。可读，小而美。核心是抽象，抽象是需要自己去悟！！！
            编辑器回放：读的时间是写的时间的10倍

    第2章.有意义的命名：
        答：1.名副其实。如果名称需要注释来补充，就不算名副其实。
                代码不能出现模糊度。让每段代码看起来有意义。
                    比如：这个list是什么类型的东西？ 改进措施：修改名称为有意义的名字
                          它的0下标的意义是什么？            修改有有名字的常量
                          这个魔数4是什么含义？              修改为有名字的常量
                          我怎么使用方法返回值？             修改返回值名字
                                                           将int[]数组修改为对象，if判断修改为对象方法
                案例举例：混乱的代码：
                    public List<int[]> getThem(){
                        List<int[]> list1=new ArrayList<int[]>();
                        for(int[] x:theList){
                            if(x[0]==4){
                                list1.add(x);
                            }
                        }
                        return list1;
                    }
                修改后的好代码：
                    public List<Cell> getFlaggedCells(){
                        List<Cell> flaggedCells=new ArrayList<Cell>();
                        for(Cell cell:gameBoard){
                            if(cell.isFlagged){
                                flaggedCells.add(cell);
                            }
                        }
                        return flaggedCells;
                    }
                总结：1.改变量名字；2.改变量类型；3.将if判断修改为对象方法
            2.避免误导：
                不要留下错误线索注释，或者遗留与本意相反的名字
                变量命名不要用类型名。比如list集合的命名后缀不要用List,而是应该用s【非常重要！！！这是自己之前代码常犯的错误】
                    accountList: 错误范例。
                    accounts, accountGroup, bunchOfAccounts: 正常范例
                不要用小写字母l和大写字母O做变量名，因为他们看起来像数字1和0
            3.做有意义的区分：
                1.以数字系列命名毫无意义：因为你完全无法区分a1,a2,a3的区分是什么
                2.废话是另一种没意义的区分：举例如下
                        Product 和ProductInfo 和ProductData 没意义区别
                        a 和an 和the 没意义区别
                        缺少约定： moneyAmount 和money没区别
                                  customerInfo 和customer没区别
                                  accountData 和account没区别
                                  theMessage 和message没区别
                                  Customer 和CustomerObject没区别
                        NameString 不比Name命名好，难道Name会是一个浮点数吗？
                3.不要在变量中命名Variable,不要在表命名中Table,因为他们是关键字
                核心是做到：真正有意义的不同命名区分。
            4.使用读的出来的名称：
                使用英文单词，而不是自造词，或者缩写词。这样不利于交流
                案例：
                    反例：genymdhms 表示生成时间戳
                    正例：generationTimestamp 表示生成时间戳
            5.使用可搜索的名称：
                长名胜过短名，因为它有意义而且能够快速找到，虽然拉长了代码量
                案例： s,t,j 比不过realTaskDays的命名，因为后者方便搜索
            6.编码使用编码：
                不要把类型和作用域放入命名中。它是多余的负担
                反例：accountsList，List没必要再放入名称中
                匈牙利语标记法（HN）：
                    背景：之前编译器不做类型检查，变量命名必须附加类型说明
                    现在：编辑器进化，java强类型，已经不需要这样命名了。它徒增阅读难度
                    反例：phoneNumber ,phoneString
                成员前缀：
                    不要使用，人们习惯忽略前缀，它是旧时代的产物
                接口和实现的使用：
                    案例：接口/实现类：IShapeFactory / ShapeFactory
                          I前缀被接口滥用编码了。我们不想让客户知道它是接口，而是一个工厂
                          作者的建议：接口/实现类： ShapeFactory / CShapeFactory或者ShapeImpl
                    总之，就是不要对接口编码, 宁可Impl实现类后缀编码，也不是要I接口前缀编码
            7.避免思维映射：
                不要把你熟悉的命名缩写当做别人也知道这个命名缩写，因为你们两个对于同一个缩写可能有不同的理解
                一定要明确含义
            8.类名
                应该是名词，不应该是动词。不应该区分度差，具象化要高才行
                案例：好的命名：Customer, WikiPage,Account,AddressParser
                      坏的命名：
                         Manager： 命名不够具象化【非常重要，目前公司的命名就是不符合规范的！！！】
                         Processor： 命名不够具象化
                         Data: 区分度较差
                         Info: 区分度较差
            9.方法名：
                使用动词或者动词短语：比如postPayment,deletePage,save, getXXX(),setXXX(),isXXX()
                带参构造器：使用静态工厂方法，对应私有构造器private修饰
                    反例：Person a=new Person(23)
                    正例：Person a=Person.FromNumber(23)
            10.别扮演可爱：
                别用whack()来表示kill(),别用eatMyShorts()表示abort()。不要用典故命名，别人可能不知道这个典故
            11.每个概念对应一个词
                功能: 它是一个控制器类。那么命名就都用controller，而不应该有的用controller,有的用manager,还有的用driver.
                     命名风格要统一，根据不同功能层级使用不同的后缀等
            12.别用双关语：
                平装书模式：大众化写清楚
                学院派模式：挖地三尺才明白含义
                举例：addxxx()方法：比如现在表示1个参数放入到集合中；那么另外的功能，将a+b=c也用addXXX()方法就不合适，它导致双关了
            13.使用解决方案领域名称【对于代码协作者】
                你的代码只有程序员阅读，就不要使用业务领域名称。而是计算机灵越名称
                比如GSP是医药业务领域的校验，那么在代码中校验方法就不要写成gsp(),而应该写成validate(), 因为别人会跑去问客户，gsp是啥，他本质是一个校验方法
            14.使用问题领域名称
                这是退而求其次，找不到合适的计算术语的时候，可以去请教业务专家。如果某段代码核心是业务领域，那么就使用业务领域命名。
            15.添加有意义的语境：
                 场景：1个方法中有多个变量，这些变量在算法中流转。
                      初次看到不知其意，将其封装为对象中变量，提供有意义的函数，命名空间，让这些变量变得容易理解
                 比如：firstName我们知道是名字，但是不知道具体是什么名字
                       addrFirstName我们知道是地址的名字，通过增加前后缀，我们知道了这个变量的语境，虽然这是最不推荐的方法
                       我们推荐使用封装一个Address对象，封装一个firstName来表示地址名称。这些提供语境更容易理解，并且易于后续拆分
            16.不要添加没用的语境：
                不要增加无用的前缀。
                短名称足够清楚，有明确的语境，就要比长名称好。别给名称增加不必要的语境
                比如：MAC地址，端口地址，Web地址的命名
                    反例：MacAddress, PortAddress,WebAddress。他们增加了不必要的语境，也就是不必要的后缀。不增加后缀也能过清楚的明白含义
                    正例：Mac,URI,PostalAddress
                总结：精确命名才是重点

    第3章.函数：
        答：1.短小，函数20行封顶最佳
                if/else/while语句代码应该只有1行，该行是一个函数。
                函数不应该容纳嵌套结构，缩进不应该大于两层
                一个函数只能有1个if语句，if语句之后不能够再有其他功能。如果是校验功能的if,那么一个函数中可以有多个if。
            2.只做一件事，做好一件事
                核心是做功能抽象，同一抽象层上的多个步骤，也叫作只做一件事。
                缩短到无法再缩短则抽象结束。重新诠释函数和抽象函数不是同一个概念
                判断函数是否只做一件事：看看能不能继续抽象，而不是单纯的重新诠释代码。通俗的讲：如果还能功能多合一，则还能抽象
            3.每个函数一个抽象层级
                较高抽象：getHtml()
                中间抽象：path=PathParser.render(page)
                低级抽象：.append("\n")
                自定向下读代码：一个类中写大量的方法，每个方法的内容都不长。
            4.switch语句：
                不要使用switch语句。尽管他无法避免。
                解决办法：将switch放到抽象工厂，使用接口多态进行区分不同情况
            5.使用描述性名称：
                给方法取名要花费心思，易于描述
            6.函数参数：
                优劣比较：0参最好，1参次之，2参避免，3参禁止
                最好的方法是：入参和返回值都没有，全部在方法外部进行修改。有参数和返回值之后，函数变得难以理解
                一元函数普遍形式：
                    将某个参数转化为另外的形式：public B convertAToB(A a){}
                    事件状态：void updateState(A a){}
                    其他形式的一元函数都不是好函数
                方法中传入boolean类型不能容忍，因为它做了不止一件事。最好将该方法拆分为两个方法
                二元函数：最好不用，如果向POint p=new Point(x,y);这种也是可以的，他们两个参数间整体存在联系。没联系的两个参数就不要使用
                三元函数：禁止使用
                参数对象：将多远函数转化为一元函数的方案：将参数封装成一个统一的对象，让他们处于统一的概念【重要！！！】
                参数列表：可变参数类似于List
                动词与关键字：方法名是动词，参数是名词。比如writeFiled(name)。将参数的名称编码转化为函数名
            7.无副作用：
                函数名称应该只做一件事，而不要在内部做隐藏的事情，这样会出问题。
                输出参数：避免使用输出参数，因为这样会花时间看函数的意义。
            8.分隔指令：
                函数要门做什么事，要回答什么事，二者不可兼得。否则违反了一个函数只做一件事的规定
                反例：if(set("username","bob"))
                正例：if(attributeExists("username")){
                        setAttribute("username","bob")
                      }
            9.使用异常替代返回错误码：
                if语句中不要进行返回值判断，这感觉要求调用者立刻处理错误。可以使用异常替代。将错误处理代码从主路径中分离出来。
                而且将try-catch抽离出来，不要把它和主业务混在一起。也就是方法上判处异常。
                错误处理应该只是一件事，如果一个方法中有try,那么catch/finally后面就不应该有其他内容
                Error.java依赖磁铁：异常枚举不要使用，因为一旦某个枚举修改，则调用者需要重新部署。建议使用异常替代错误码
                反例：if(deletePage(page)==E_OK)
                正例：try{
                        deletePage(page)
                     }catch(Exception e){
                        ......
                     }
            10.别重复自己：
                可读性因为消除重复而得到提升，一切的代码创新都是从源码中消除重复。
            11.结构化编程：
                一个入口，一个出口。只有一个return，循环中不能够有break, continue,goto。
                只要函数够小，可以小小违背

    第4章.注释：
        注释是一种必须的恶。注释总是一种失败。需要写注释的代码都是垃圾。
        只有代码才能最真实表达业务，就像数据库约束才能表达业务约束一样
        1.注释不能美化糟糕代码
            发现垃圾代码的解决方法：不是写注释，而是将代码写干净。尽管这样可能会影响业务逻辑，可能导致bug。但是改好了一切都不同了。不要畏惧修改别人的代码
        2.用代码来阐释
            与其写注释，不如想一个同名的方法来重构
        3.好注释：
            法律信息：
                它是一个索引指向外部文档
            提供信息的注释：
                无法通过设置方法名来提供信息的注释，还是可行。但最好还是封装到类中
            对意图的解释：
                注释反应某段算法，某个取值为什么这么取，这种注释是可取的
            阐释：
                对无法修改的基础包，需要阐释，但是要小心注释的正确性【非常重要，实际上应该很容易遇到！！！】
            警示：
                解释某段代码执行的后果。比如@Ignore("takes too long to run")来关闭测试用例
                有很强大说服力的警示注释，是可取的
            TODO：
                将后续待处理的代码标识出来，这很有必要
            放大：
                注释的方法也可以将某个方法的作用放大，提示可能存在的bug
            公共API中的Javadoc：
                一个好的api文档注释让人心情愉悦
        4.坏注释
            为糟糕代码提供接口的注释就是坏注释，程序员的为自己的错误决策的自说自话就是坏注释
            1.喃喃自语：
                最怕作者后面再补上代码，这里写注释只是自我安慰
                任何让读者看其他模块的注释，都是垃圾
            2.多余的注释：
                它没有证明代码的意义，也没有给出代码的意图或逻辑
                tomcat中就存在这种无用而多余的注释
            3.误导性注释：
                注释和代码南辕北辙
            4.循规式注释：
                让每个方法都写上注释，愚蠢！！【某些公司的规定就是可笑！！】
            5.日志式注释：
                记录这个方法的全部修改过程。除非你没有版本控制工具，否则应该全部删除【这个也很重要】
            6.废话注释：
                毫无意义。用整理代码来替代创造废话。你会发现自己更快乐


    第5章.格式：
    第6章.对象和数据结构
    第7章.错误处理：
    第8章.边界：
    第9章.单元测试：
    第10章.类：
    第11章.系统：
    第12章.迭进：
    第13章.并发编程：
    第14章.逐步改进：
    第15章.JUnit内幕：
    第16章.重构SerialDate:
    第17章.味道和启发：
2.开始学习书本章节：
    附录：并发编程
        1.客户端/服务器的例子
        2.执行的可能路径
        3.了解类库
        4.方法之间的依赖可能破坏并发代码
        5.提升吞吐量
        6.死锁
        7.测试多线程代码
        8.测试线程代码的工具支持

