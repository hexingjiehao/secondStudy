1.STL中vector的实现原理 (衍生：Map, Set等实现原理)？【OK】
答：
vector的数据安排以及操作方式，与array非常相似。两者的唯一区别在于空间的运用的灵活性。array是静态空间，一旦配置了就不能改变；要换个大（或小）一点的房子，可以，一切琐细都得由客户端自己来：首先配置一块新空间，然后将元素从旧址一一搬往新址，再把原来的空间释还给系统。vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。因此，vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必因为害怕空间不足而一开始要求一个大块头的array了，我们可以安心使用array，吃多少用多少。
vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率。一旦vector的旧有空间满载，如果客户端每新增一个元素，vector的内部只是扩充一个元素的空间，实为不智。因为所谓扩充空间（不论多大），一如稍早所说，是”  配置新空间/数据移动/释还旧空间  “的大工程，时间成本很高，应该加入某种未雨绸缪的考虑。稍后我们便可看到SGI vector的空间配置策略了。
另外，由于  vector维护的是一个连续线性空间，所以vector支持随机存取  。
注意：vector动态增加大小时，并不是在原空间之后持续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，  对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了  。这是程序员易犯的一个错误，务需小心。


2.给定N张扑克牌和一个随机函数，设计一个洗牌算法？【OK】
答：
本质是交换数组中的两个值的位置。
void shuffle(int cards[],int n)
{
    if(cards==NULL)
        return ;
    srand(time(0));
    for(int i=0;i<n-1;++i)
    {
        //保证每次第i位的值不会涉及到第i位以前
        int index=i+rand()%(n-i);
        int temp=cards[i];
        cards[i]=cards[index];
        cards[index]=temp;
    }
}


3. 25匹马，5个跑道，每个跑道最多能有1匹马进行比赛，最少比多少次能比出前3名？前5名？【OK】
答：
本质是每匹马估算自己最大可能的名次，然后再通过比赛进行确定。
找出前3名最少需要7场就可以确定。首先我们将25匹⻢马分成5组，分别为ABCDE，5组分别进行比赛决出各小组名次；
接着让各小组第一进行比赛决出冠军，我们假设各小组第一分别是A1, B1, C1, D1, E1，并且速度A1 > B1 > C1 > D1 > E1；
接着2，3名可以在一场比赛内决出，分别由A2, A3, B1, B2, C1参赛；这样总共进行了5 + 1 + 1 = 7场；
找出前5名的思路和这个类似。


4. 100亿个整数，内存足够，如何找到中位数？内存不足，如何找到中位数？【OK】
答：
内存足够的情况： 可以使⽤用类似quick sort的思想进行，均摊复杂度为O(n)，算法思想如下：
• 随机选取一个元素，将比它小的元素放在它左边，比它大的元素放在右边
• 如果它恰好在中位数的位置，那么它就是中位数，可以直接返回
• 如果小于它的数超过一半，那么中位数一定在左半边，递归到左边处理
• 否则，中位数一定在右半边，根据左半边的元素个数计算出中位数是右半边的第几大，然后递归 到右半边处理
内存不⾜足的情况：
    ⼆分法思路：一个重要的线索是，这些数都是整数。整数就有范围了，32位系统中就是[-2^32, 2^32- 1]， 有了范围我们就可以对这个范围进行二分，
然后找有多少个数⼩于Mid,多少数大于mid，然后递归， 和基于quicksort思想的第k大⽅方法类似
    分桶法思路：化大为小，把所有数划分到各个小区间，把每个数映射到对应的区间⾥里，对每个区间中数的 个数进行计数，
数一遍各个区间，看看中位数落在哪个区间，若够小，使⽤用基于内存的算法，否则 继续划分


5.如何处理循环引用问题？【OK】
答：
代码中，a对象引用了b对象，b对象也引用了a对象，这种情况下a对象和b对象就形成了循环引用。
引用计数GC不能解决循环引用
引用对象遍历GC能够解决循环引用。


6.引用和指针有什么区别？【OK】
答：
本质：引用是别名，指针是地址，具体的：
• 指针可以在运行时改变其所指向的值，引用一旦和某个对象绑定就不再改变
• 从内存上看，指针会分配内存区域，而引用不会，它仅仅是一个别名
• 在参数传递时，引⽤用会做类型检查，而指针不会
• 引用不能为空，指针可以为空

7. 1000个灯围成一个环，初始状态是熄灭的，按一个灯，它以及它的左右两盏灯的状态会改变，问 如何让所有灯都亮？【OK】
答：
挨个按一遍。思路是每个灯只会被3个位置改变状态，挨个按一遍恰好每个位置被改变了奇数次状态


8.n条直线最多能将一个平面分成多少部分？【OK】
答：
本质是：讲前面的线都切分。f(n)=n(n+1)/2+1


9. 同一数轴，有两个机器人。给这两个机器人输入一段相同的程序,使得这两个机器人保证可以相遇。【OK】
答：
两个机器人同时开始以单位速度右移，直到一个机器人走到另外一个机器人的起点处。然后，该机器人以双倍速度追赶对方


10. 有 n 个人互相比赛（n已知), 一个人输掉 4 次就出局(不能继续比赛),赢 7 次通过(可以继续比赛), 问最多通过人数?【OK】
答：
本质是：一个部分一直输，赢的人输了3场。
赢的是x， 输的是 y ， 那么 x+y=n;
假设包括赢的人，每个人都输了3次，那么就有3n 个胜场，然后输的人y再输一场，那就有
3n + y个胜场，因为 赢7次才算赢，那么3n+y >= 7x
联立二元一次方程组，解得：
那么x <= n/2
即，一半的人会赢


11.两个软硬程度一样的鸡蛋，它们在某一层摔下会碎，有个100层的建筑，
要求最多用两个鸡蛋确 定鸡蛋安全下落的临界位置，给出临界位置？
如果是n层楼，m个鸡蛋，请给出确定临界位置的算法【OK】
答：
注意：鸡蛋不碎得话，还能继续用。
状态转移方程：假设f[n]表示从n层楼找到摔鸡蛋不碎安全位置的最少判断次数
状态转移方程：f[n] = min{ 1 + max(i - 1 ,f[n - i]) | i = 1 ..n }
初始条件: f[ 0 ] = 0 （或f[ 1 ] = 1 ）

状态转移方程：f[n,m] = min{ 1 + max(f[i - 1 ,m - 1 ], f[n - i,m]) | i＝ 1 ..n }
初始条件：f[i, 0 ] = 0 （或f[i, 1 ] = i），对所有i


12.n个人，只有1个人是明星，明星所有人都认识，但明星不认识其他任何人，如何找到该明星？如果n很大很大，如果改进你的算法？【OK】
答：
线性扫描一遍，两两比较，每次比较都会排出一个人：若a认识b，则a一定不是明星；若a不认 识b，则b一定不是明星；
n很大的情况下可以采用分布式方法，每个机器处理一部分数据，最后每个 机器选出一个候选，归并


13.一个绳子从一头开始烧是1小时，要求想办法测出45分钟。【OK】
答：
用甲乙两根绳.先同时点燃甲的两端以及乙的一端，当甲烧完后过去了30分钟,
因为是两头烧,所以就是30分钟.而乙已经烧了30分钟,还有30分钟的量,
此时再点燃乙的另一端.双管齐下,剩下的30分钟只烧了15分钟,加上一开始已经烧了30分钟,共45分钟


14.囚犯猜帽子问题？【OK】
答：保证n-1个人被释放。利用奇数偶数原则。


15.如何等概率地从n个数中随机抽出m个数？【OK】
答：
本质是连续乘法:最终约分的结果是一致的。
蓄水池采样法：每个位置i以(m - k)/(n - i + 1)的概率决定当前数是否选，k为前面已经抽出的数的个数


16.给定一个能够生成0,1两个数的等概率随机数生成器”，如何生成⼀个产生0,1,2,3的等概率随机数生成器?和上题类似，如何用rand7生成rand9?【OK】
答：
本质是：做映射关系。
将两个0,1随机生成器级联，每次产生两个数，则可能的结果有(0,0), (0,1), (1,0), (1,1)，分别映 射到0, 1, 2, 3即可
两个rand7可以产生49种可能，扔掉后面的4种，保留前45个，并平均分成9份，每次产生一个结果时，假如没落在对应区间中就扔掉，否则根据落在哪个区间判断是0--8中哪个


17.有一枚硬币,以p的概率产生正面，以1-p的概率产生背面，如何利用它产生个0.5概率的生成器？【OK】
答：
将两枚硬币级联，只保留“正反”，“反正”两种结果，其他两种结果扔掉


18. A,B,C三人轮流扔硬币，第一个扔到正面的人算赢，问三个人赢的概率分别为多大？【OK】
答：
P(B) = 1/2*P(A); P(C) = 1/4 * P(A); P(A) + P(B) + P(C) = 1;
得P(A) = 4/7, P(B) = 2/7, P(C) = 1/7


19.A 有 n 个硬币,B 有 n+1 个硬币,谁丢的正面多谁赢,问 A 不输的概率？【OK】
答：
前n个硬币，有3种情况，设P(A>B) = x, P(A == B) = y，由对称性P(A<B) = x，则有2x + y = 1
现在来看B扔最后一个硬币的情况：
• 假如之前A>B，则无论怎么扔，A都不会输，最多平
• 如果A==B,则B扔了正面，A才会输，这是0.5y
• 如果A<B，则无论B怎么扔，A都输,所以是x
所以A输的概率是：x + 0.5y = 0.5 * (2x + y) = 0.5，A不输的概率是1 - 0.5 = 0.5


20.一个机器人在原点，右边有一个距离为k的点，机器人以p的概率右移一步，1-p概率左移一步， 问经过M步机器人处于k点的概率?【OK】
答：
k步右移，剩下的M - k步一半左移一半右移，所以M<k和(M - k)%2 == 1的情况概率为0，其他情 况就是M中选k + (M-k)/2步的概率。


21.扔硬币直到连续两次出现正面，求扔的期望次数？【OK】
答：
假设期望次数是E，我们开始扔，有如下几种情况：
• 扔到的是反面，那么就要重新仍，所以是0.5*(1 + E)
• 扔到的是正面，再扔一次又反面了，则是0.25*(2 + E)
• 扔到两次，都是正面，结束，则是0.25*2
所以递归来看E = 0.5*(1 + E) + 0.25*(2 + E) + 0.25*2，解得E = 6


22.同样可以实现互斥，互斥锁和信号量有什么区别？【OK】
答：
信号量是一种同步机制，可以当作锁来用，但也可以当做进程/线程之间通信使用，作为通信使用时不一定有锁的概念；
互斥锁是为了锁住一些资源，是为了对临界区做保护


23.编程实现三个线程ABC，并让它们顺次打印ABC【OK】
答：
思路：设置三个信号量：S1, S2, S3，S2由S1 post，S3由S2post, S1由S3 post，由A线程先开 始打印，其他线程必然在等待信号量，所以三个线程⼀一定会按照信号量的顺序来打印


24.简述Linux进程内存空间分为哪几个段？作用分别是什么？【OK】
答：
核心空间
栈
存储映射部分
堆BSS部分
文本部分


25.简述Linux内存分配--伙伴系统原理？【OK】
答：
伙伴系统，其思想是：把内存块分成不同的组(1,2,4,8,16,32....)；
分配内存时找到能够满足条件 的最小的块；如果找不到，就找大的块，然后一分为2，分配一块，留一块；
回收时：如果有相邻的同样大小的块，则合并


26.简述Malloc实现原理？【OK】
答：
可以基于伙伴系统实现，也可以使用基于链表的实现
• 将所有空闲内存块连成链表，每个节点记录空闲内存块的地址、大小等信息
• 分配内存时，找到大小合适的块，切成两份，一分给用户，一份放回空闲链表
• free时，直接把内存块返回链表
• 解决外部碎片：将能够合并的内存块进行合并


27.使用mmap读写文件为什么比普通读写函数要快？
答：
mmap函数：可以将文件映射到内存中的一段区域，普通函数读写文件：用户空间buffer内核空间buffer磁盘；
mmap映射之后：用户空间buffer进程内存空间，省掉了拷贝到内核空间的时间。


28.Linux中如何实现Signal?【OK】
答：
基于软中断，不同Signal对应不同中断处理函数


29.设计并实现一个LRU Cache？【OK】
答：
• 重要数据结构：key-value存储、LRU存储链表；
• key-value存储：hash_table/map，LRU：链表，因为可以快速实现增加、删除
• 如何更新Cache: 找到key在链表中的位置，删除并将它插到表头，同时更新key到链表位置的映射
• 快速找到最不常访问的元素：链表尾


30.设计一个数据结构，能够支持插入、删除、返回最大值、最小值、随机返回一个数的操作？【OK】
答：
插入、删除、最大、最小：使用set实现，复杂度O(logn)
如何实现random 使用数组，将所有数据放入数组中，random时随机返回数组元素
记录每个元素在数组中的下标 • 删除时首先将对应元素和最后一个元素交换，删除最后一个元素 复杂度O(1)


31.设计qps (query per sec)函数，用它控制api调用，使得api n毫秒内只能被调用m次?【OK】
答：
维护一个窗口，窗口有左右两个边界；窗口内为从最后一次访问开始向前n毫秒所有的访问?
当新来一个访问，更新窗口右边界，打新的时间戳；向右移动窗口左边界，将距当前n毫秒外的访 问删除
统计次数看是否满足<= m次?


32.如何设计一个短网址服务系统？【OK】
答：
将url哈希到一个唯一的数值，将这个数值转化为一个字符串； 另外还需要考虑系统负载等因素


33.如何设计一个网页爬虫系统？【OK】
答：
使用bfs算法进行网站爬取；
使用master节点作为控制节点控制work 节点进行网站爬取；
使用分布式队列做任务调度；
使用key-value存储（如redis)做网页判重


34.给一个超过100G大小的log file, log中存着IP地址, 设计算法找到出现次数最多的IP地址？
    与上题条件相同，如何找到top K的IP？
    如何直接用Linux系统命令实现？【OK】
答：
Hash分桶法：
• 将100G文件分成1000份，将每个IP地址映射到相应文件中：file_id = hash(ip) % 1000
• 在每个文件中分别求出最高频的IP，再合并 Hash分桶法：
• 使用Hash分桶法把数据分发到不同文件
• 各个文件分别统计top K
• 最后Top K汇总
Linux命令，假设top 10：sort log_file | uniq -c | sort -nr k1,1 | head -10


35.给定100亿个整数，设计算法找到只出现一次的整数【OK】
答：
Hash分桶法，将100亿个整数映射到不同的区间，在每个区间中分别找只出现一次的整数


36.给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集【OK】
答：
使用hash函数将第一个文件的所有整数映射到1000个文件中，
每个文件有1000万个整数，大约40M内存，内存可以放下，
把1000个文件记为 a1,a2,a3.....a1000,用同样的hash函数映射第二个文件到1000个文件中，
这1000个文件记为b1,b2,b3......b1000，由于使用的是相同的hash函数，所以两个文件中一样的数字会被分配到文件下标一致的文件中，
分别对a1和b1求交集，a2和b2求交集，ai和bi求交集，最后将结果汇总，即为两个文件的交集


37. 1个文件有100亿个int，1G内存，设计算法找到出现次数不超过2次的所有整数?【OK】
答：
Bitmap扩展：⽤用2个bit表⽰示状态，0未出现过，1出现过1次，2出现了2次或以上


38.给两个文件，分别有100亿个query，我们只有1G内存，如何找到两个文件交集？分别给出精确 算法和近似算法?【OK】
答：
精确算法：Hash分桶法
• 将两个文件中的query hash到N个小文件中，并标明query的来源
• 在各个小文件中找到重合的query
• 将找到的重合query汇总
近似算法：BloomFilter


39.如何扩展BloomFilter使得它支持删除元素的操作？【OK】
答：
将Bloomfilter中的每一位扩展为一个计数器，记录有多少个hash函数映射到这一位；
删除的时候，只有当“引用计数”变为0时，才真正将该位置0


40.如何扩展BloomFilter使得它支持计数操作？【OK】
答：
将Bloomfilter中的每一位扩展为一个计数器，每个输入元素都要把对应位置加1，从而支持计数 操作。
计数个数为：所有映射到的位置中计数的最小值


41.有一个词典，包含N个英文单词，现在任意给一个字符串，设计算法找出包含这个字符串的所有英文单词【OK】
答：
给输入字符串，利⽤字母建立倒排索引，索引中存储该字母 出现在哪个单词以及在单词中位置；查询时，利用倒排找到所有的单词，并求交集并且位置要连续