1.动态链接库和静态链接库的优缺点?【OK】
答：
（1）动态链接库(Dynamic Linked Library)：
Windows为应用程序提供了丰富的函数调用，这些函数调用都包含在动态链接库中。其中有3个最重要的DLL，Kernel32.dll、User32.dll和GDI32.dll。有两种使用方式：一种是静态加载，即在应用程序启动时被加载；一种是动态加载，即是该动态链接库在被使用时才被应用程序加载。
优点如下：
a. 共享：多个应用程序可以使用同一个动态库，启动多个应用程序的时候，只需要将动态库加载到内存一次即可；
b. 开发模块好：要求设计者对功能划分的比较好。
缺点是不能解决引用计数等问题。
（2）静态库(Static Library)：函数和数据被编译进一个二进制文件(通常扩展名为.LIB)。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件(.EXE文件)。静态链接库作为代码的一部分，在编译时被链接。
优缺点如下：
a.代码的装载速度快，因为编译时它只会把你需要的那部分链接进去，应用程序相对比较大。但是如果多个应用程序使用的话，会被装载多次，浪费内存。


2.列出数据库中常用的锁及其应用场景【SQLServer重要！OK】
答：
SQL Server中锁模式包括：
1）共享锁： SQL Server中，共享锁用于所有的只读数据操作。共享锁是非独占的，允许多个并发事务读取其锁定的资源。默认情况下，数据被读取后，SQL Server立即释放共享锁。例如，执行查询“SELECT * FROM my_table”时，首先锁定第一页，读取之后，释放对第一页的锁定，然后锁定第二页。这样，就允许在读操作过程中，修改未被锁定的第一页。但是，事务 隔离级别连接选项设置和SELECT语句中的锁定设置都可以改变SQL Server的这种默认设置。例如，“ SELECT * FROM my_table HOLDLOCK”就要求在整个查询过程中，保持对表的锁定，直到查询完成才释放锁定。
2）修改锁： 修改锁在修改操作的初始化阶段用来锁定可能要被修改的资源，这样可以避免使用共享锁造成的死锁现象。因为使用共享锁时，修改数据的操作分为两步，首先获得一个共享锁，读取数据，然后将共享锁升级为独占锁，然后再执行修改操作。这样如果同时有两个或多个事务同时对一个事务申请了共享锁，在修改数据的时候，这些 事务都要将共享锁升级为独占锁。这时，这些事务都不会释放共享锁而是一直等待对方释放，这样就造成了死锁。如果一个数据在修改前直接申请修改锁，在数据修 改的时候再升级为独占锁，就可以避免死锁。修改锁与共享锁是兼容的，也就是说一个资源用共享锁锁定后，允许再用修改锁锁定。
3）独占锁： 独占锁是为修改数据而保留的。它所锁定的资源，其他事务不能读取也不能修改。独占锁不能和其他锁兼容。
4）结构锁： 结构锁分为结构修改锁（Sch-M）和结构稳定锁（Sch-S）。执行表定义语言操作时，SQL Server采用Sch-M锁，编译查询时，SQL Server采用Sch-S锁。
5）意向锁： 意向锁说明SQL Server有在资源的低层获得共享锁或独占锁的意向。例如，表级的共享意向锁说明事务意图将独占锁释放到表中的页或者行。意向锁又可以分为共享意向锁、 独占意向锁和共享式独占意向锁。共享意向锁说明事务意图在共享意向锁所锁定的低层资源上放置共享锁来读取数据。独占意向锁说明事务意图在共享意向锁所锁定 的低层资源上放置独占锁来修改数据。共享式独占锁说明事务允许其他事务使用共享锁来读取顶层资源，并意图在该资源低层上放置独占锁。
6）批量修改锁： 批量复制数据时使用批量修改锁。可以通过表的TabLock提示或者使用系统存储过程sp_tableoption的“table lock on bulk load”选项设定批量修改锁。


3.轮询任务调度和可抢占式调度有什么区别？【OK】
答：
（1）轮询调度的原理是每一次把来自用户的请求轮流分配给内部中的服务器，从1开始，直到N(内部服务器个数)，然后重新开始循环。
        只有在当前任务主动放弃CPU控制权的情况下（比如任务挂起），才允许其他任务（包括高优先级的任务）控制CPU。
        其优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。但不利于后面的请求及时得到响应。
（2）抢占式调度允许高优先级的任务打断当前执行的任务，抢占CPU的控制权。这有利于后面的高优先级的任务也能及时得到响应。
        但实现相对较复杂且可能出现低优先级的任务长期得不到调度。


4.数据库以及线程发生死锁的原理及必要条件，如何避免死锁？【OK】
答：
产生死锁的原因主要是：
（1） 因为系统资源不足。
（2） 进程运行推进的顺序不合适。
（3） 资源分配不当等。
产生死锁的四个必要条件：
（1）互斥条件：一个资源每次只能被一个进程使用。
（2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3）不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
（4）循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
避免死锁：
    使用银行家算法


5.面向对象的三个基本元素，五个基本原则？【OK】
答：
三个基本元素：
    封装
    继承
    多态
五个基本原则：
    单一职责原则（Single-Resposibility Principle）:一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。
    开放封闭原则（Open-Closed principle）:软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。
    Liskov替换原则（Liskov-Substituion Principle）:子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。
    依赖倒置原则（Dependecy-Inversion Principle）:依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。
    接口隔离原则（Interface-Segregation Principle）:使用多个小的专门的接口，而不要使用一个大的总接口。


6.windows内存管理的机制以及优缺点？【OK】
答：
分页存储管理基本思想：
    用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。
分段存储管理基本思想：
    将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。
段页式存储管理基本思想：
    分页系统能有效地提高内存的利用率，而分段系统能反映程序的逻辑结构，便于段的共享与保护，将分页与分段两种存储方式结合起来，就形成了段页式存储管理方式。
在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位。
段页式系统中，作业的地址结构包含三部分的内容：段号      页号      页内位移量
程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机构将段内位移量分解为页号和页内位移量。
为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块号。


7.JAVA和C++的区别是什么?分别用在什么情景比较好?【OK】
答：

1、JAVA纯面向对象，C++面向对象和面向过程；
2、内存管理方面：JAVA具有自带的GC垃圾回收器,c++需要自己进行垃圾回收；
3、语言特点上：C++保留了指针，而JAVA则取消了这一概念，用引用来直接表示对象；
4、语言分类上：C++属于编译型语言，而JAVA属于解释型语言
5、语言效率上：C++往往具有更高的效率，JAVA因为需要在自身虚拟机上运行，效率稍弱，
当同一个应用程序需要在不同平台上运行时宜采用JAVA，因其良好的可移植性，JAVA一般作为应用层；
当要求程序具有高效率时宜采用C++，如系统底层环境的开发。


8.什么是DDoS攻击？常见的DDoS攻击有哪些方式？常用的应对DDoS攻击的方法有哪些？【OK】
答：
DDoS：Distributed Denial of Sevice，就是利用合理的服务请求，占用大量的服务器资源，使用合法的用户无法得到服务器的响应。
常见方式：SYN Flood、UDP Flood、IP Spoofing、LAND attack、ICMP Flood等（回答3个即可）。
常用的应对方式：关闭不必要的服务；限制同时打开的SYN半连接数目；缩短SYN半连接的time out时间；利用防火墙和路由器的访问控制列表限制SYN数据包流量速率等。


9.常用的进程间通信的方式？【OK】
答：
共享内存、套接字、信号量、消息队列、管道等。


10.你知道哪些动态路由协议，相比于静态路由，动态路由协议有哪些优缺点？【OK】
答：
OSPF、BGP、ISIS、RIP等（答出2、3种即可），
优点：动态路由协议可以自适应网络状态的变化，不需要网路管理员的参与；缺点：交换路由信息的过程消耗网络资源，占用网络带宽；安全性不如静态路由。