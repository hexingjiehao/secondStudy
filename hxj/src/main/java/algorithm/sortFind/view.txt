1.常用的排序和查找学习
    1.排序学习：
        内部排序：
            需要元素进行比较的排序：
                1.插入排序：(类似于抓扑克)
                    直接插入：顺序查找插入位置,逐个将序列按照大小顺序插入
                    折半插入：查找插入位置时采用折半查找
                    希尔排序：(缩小增量)
                             按照增量k(一般取n/2)分割子序列,单独插入排序。然后减小增量k再来一遍插入排序。直到k=0
                2.冒泡排序：
                    低位冒泡排序：逐个相邻两个元素比较，逆序则交换。必须是挨着的
                    鸡尾酒排序：排序位置，从低->高->低,逐个向中间靠拢循环。
                3.选择排序：
                    每次找一个最值放到指定位置，循环n遍
                4.堆排序：(父与子的节点大小关系----所有的节点关系一致称为堆)
                    1.先建堆：
                        最后一个分支节点开始往上，每次和子节点进行大小比较构成堆
                    2.堆排序：
                        从最后1个节点开始逐个往上，每次和堆顶元素交换，重新组建堆。直到根节点
                5.归并排序：
                    将多个有序表进行合并。递归方式实现，left/right->merge。具体是双表遍历，逐个插入到新表成有序表
                6.快速排序：
                    找哨兵,从反方向找比它大的,找到了和哨兵交换位置，然后开始反转比它小的，直到两个的位置重叠。哨兵最后的位置确定。最后循环n遍
            非比较排序：(计数)
                1.基数排序：
                    1.多关键字排序：(字符串的格式一直)，最高为优先/最低位优先,逐个关键字的比较
                    2.链式基数排序：分配和收集策略。所有字符情况rd,关键字位数d,总共的记录n。逐个按位形成有序链表,然后进行合并
                2.计数排序：只能整数排序。关键是中间统计个数的数据，有一个从前往后累加的操作
                    统计每个数出现的次数，然后逐个从0开始往后累加。然后开始倒序遍历，放到指定位置，然后次数减去1
                3.桶排序：
                    标记每个数据出现的次数。局限于数字类型。逐个遍历
        外部排序：略

        排序算法的稳定性：(如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的)
        排序算法的性能比较：
            1.插入排序：
                时间复杂度：O(n^2)：O(n)：O(n^2)：元素少或基本有序时高效
                空间复杂度：O(1)
                稳定性：是
            2.冒泡排序：
                时间复杂度：O(n^2)：O(n)：O(n^2)
                空间复杂度：O(1)
                稳定性：是
            3.快速排序：(推荐)
                时间复杂度：O(nlogn)：O(nlogn)：O(n^2)：平均时间性能最好
                空间复杂度：O(nlogn)
                稳定性：否
            4.希尔排序：
                时间复杂度：O( n^(3/2) )
                空间复杂度：O(1)
                稳定性：否
            5.选择排序：
                时间复杂度：O(n^2)：比较次数最多
                空间复杂度：O(1)
                稳定性：否
            6.堆排序：
                时间复杂度：O(nlogn)：辅助空间少
                空间复杂度：O(1)
                稳定性：否
            7.归并排序：
                时间复杂度：O(nlogn)：稳定的
                空间复杂度：O(n)
                稳定性：是
            8.基数排序：
                时间复杂度: O(d*(n+rd) )：最好O(nlogn):适合个数多关键字较小
                空间复杂度：O(rd)
                稳定性：是
            9.计数排序/桶排序：
                时间复杂度：O(n+k)
                空间复杂度：O(k)
                稳定性：是

    2.查找学习：(平均查找长度ASL)
        静态查找表：
            顺序查找表：逐个比较查找:(n+1)/2:O(n)
            折半查找表：有序表折半查：( log(n+1) )-1: O(logn)
            索引顺序表：分块,块间有序,块内无序。
            静态树表：
            次优查找树：
        动态查找表：
            二叉排序树：只有两叉，从左到右，由小变大：(1+n)/2
            平衡二叉树(AVL树)：|左右子树因子之差|<=1：0/1/斐波那契N=(N-1)+(n-2)+1：O(logn)
            红黑树：和AVL树类似，但不一定是平衡二叉树。因为|因子差|<=2。add/delete会调整树结构
                   根节点和null值的叶子节点是黑色，红色节点有黑色孩子节点,
                   对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点。
            B-树：m阶树非叶子节点个数【m/2,m】,非叶子根节点最少两个子树,n个关键字和(n+1)个子树
            B+树：n棵子树的节点有n个关键字，叶子节点包含所有关键字且有序排列，非叶子节点都是索引
            键树：孩子兄弟链表、多重链表
            哈希表：数组+链表+冲突解决
