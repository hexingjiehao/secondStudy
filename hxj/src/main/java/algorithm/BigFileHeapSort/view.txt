1.研究大文件的堆排序功能：
    问题：随机生成1个10G的文件，同时保证内存不溢出？【OK】
        答：生成1个1G的文件，花费1分钟左右。使用BufferedWriter即可
            最好的方法生成10G文件，分批次的追加数据到文件中，内存不会溢出

    问题进阶1：在1个2G内存运行空间的机器上，读取一个10G的乱序文件，同时保证内存不溢出
        答：java读取10G的大文件有两种方式，全部放到内存中，每次从文件只读1行
                一种是BufferedReader 的 readLine。貌似并没有全部加载到内存
                    3G的文件读取，消耗了400M内存
                第二种方式是Scanner 的 hasNextLine()这种方式以流的形式每次只读取1行，不会将所有内容都加载到内存中。
                    3G的文件读取，消耗了1G内存
            推荐方法：还是使用BufferedReader 的 readLine，只要不将所有数据都放到list，就不会内存溢出

    问题进阶2：在1个2G内存运行空间的机器上，对一个10G的乱序文件进行排序？🌿🌿🌿🌿🌿
        答：使用堆排序，每个节点的数据结构是Node{int number,int times}。每次遍历，创建大根堆。第2次遍历时，比第一次遍历完的堆最值进行比较，不处理那些已经处理过的数据。

    问题进阶3：在1个2G内存运行空间的机器上，对两个10G的有序文件进行排序
        答：使用双下标排序，写入一个合并的大文件。

    问题进阶4：在1个2G内存运行空间的机器上，对两个10G的乱序文件进行排序
        答：将两个文件分别堆排序，形成2个有序大文件，然后使用双下标排序，写入一个合并的大文件。

2.堆排序的学习：
    问题：int[]类型的堆排序实现？
        答：int[]传入方法进行堆排序，内部修改会影响到外部修改。调整堆，每次从非叶子节点进行调整
            调整的过程有递归的思想在里面，最后调整到根节点之后结束

    问题进阶1：String[]类型的堆排序实现？
        答：和int[]堆类似，字符串的比较 与int[]不同。

    问题进阶2：List<String>类型的堆排序实现？
        答：和int[]堆类似，字符串的比较和赋值 与int[]不同。

    问题进阶3：List<Node>类型的堆排序实现？Node对象的属性有value和times，分别表示值和次数
        答：注意，需要标记当前堆中的每个值Map<节点值 - 堆中下标>。如果堆不足最大范围时，要重新建堆。
            需要标记每次遍历完后，堆中的最值，下次遍历时，不碰这些值。

    问题进阶4：给定一个大数据集合，使用指定容量的List<Node>类型的堆，进行排序并输出到文件中
        答：最终实现。参照上面和代码


