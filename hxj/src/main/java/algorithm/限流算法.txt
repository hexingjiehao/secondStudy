1.学习4个主要的限流算法
    怎么做限流？
        1.通过压力测试，获取系统处理能力的上限
        2.制定干预流量的策略。比如是重视结果还是重视过程平滑性？🌿🌿🌿
        3.处理掉"被干预掉"的流量。是丢弃还是其他？
    压力测试目的：
        获取【速率】和【并发数】。xxx请求数/秒，xxx次的并发。获取最大值/平均值/中位数。
    干预流量的策略：【两窗两桶，定时清空定时器】
        固定窗口：本质是划定时间片。【预测】
            固定的时间范围，统计该范围内请求数量，达到阈值则干预，到下一个周期后，计数器清零。
            举例：

                全局变量 int totalCount = 0;  //有一个「固定周期」会触发的定时器将数值清零。
                if(totalCount > 限流阈值) {
                    return; //不继续处理请求。
                }
                totalCount++;  //请求成功
                // do something...

        滑动窗口：本质是划定时间片。【预测】
            将固定窗口拆分为更小的窗口，尽可能减少流量波动
            举例：

                全局数组 链表[]  counterList = new 链表[切分的滑动窗口数量];
                //有一个定时器，在每一次统计时间段起点需要变化的时候就将索引0位置的元素移除，并在末端追加一个新元素。
                int sum = counterList.Sum();
                if(sum > 限流阈值) {
                    return; //不继续处理请求。
                }
                int 当前索引 = 当前时间的秒数 % 切分的滑动窗口数量;
                counterList[当前索引]++;
                // do something...

        漏桶：
            固定"出口"的速率，不管进来多少量，出去的速率一直是这么多。缓冲区平滑流量
            举例：

                全局变量 int unitSpeed;  //出口当前的流出速率。每隔一个速率计算周期（比如1秒）会触发定时器将数值清零。
                全局变量 int waterLevel; //当前缓冲区的水位线。
                if(unitSpeed < 速率阈值) {
                    unitSpeed++;
                    //do something...
                }
                else{
                    if(waterLevel > 水位阈值){
                        return; //不继续处理请求。
                    }
                    waterLevel++;
                    while(unitSpeed >= 速率阈值){
                        sleep(一小段时间)。
                    }
                    unitSpeed++;
                    waterLevel--;
                    //do something...
                }

        令牌桶：
            固定"进口"的速率。先拿到令牌,再处理请求,拿不到令牌就被「流量干预」。单独线程不断生成令牌。
            举例：

                全局变量 int tokenCount = 令牌数阈值; //可用令牌数。有一个独立的线程用固定的频率增加这个数值，但不大于「令牌数阈值」。
                if(tokenCount == 0){
                    return; //不继续处理请求。
                }
                tokenCount--;
                //do something...

        计数器：一定时间内的总并发数。
        环形限流：时间差在一定范围内才请求通过


    策略选择：
        固定窗口：时间紧迫下的临时方案。
        滑动窗口：实现简单，对异常高容忍
        漏桶：通用方案。效率一般，宽进严出，保护系统。
        令牌桶：压榨程序性能，流量进入波动不大。

    分布式系统中的限流：一纵一横，纵是深入，横是添加硬件
        nginx的限流：
                    ngx_http_limit_conn_module
                    ngx_http_limit_req_module
                    这是接口层的限流
        应用层和切面层限流：
            考虑效果：客户端模式
            考虑成本：服务器端模式。【我们考虑的】

    限流的形式：就是根据某种条件，限制请求的访问
        1.限制消费者数量
        2.可以被消费数量
    本质：降低流量保证应用的高可用
    单个应用限流：RateLimiter实现令牌桶
    分布式环境的限流：redi或者infinispan
    应用场景：一般用于接口的限流，限制http请求。






