1.解决redis和db不一致的问题：【一定要去看参考文档】
    0.参考文档：https://www.cnblogs.com/myseries/p/12068845.html
    1.核心问题：你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？
    2.可能的场景：
        1个线程select，另1个线程select
        1个线程select，另1个线程insert
        1个线程select，另1个线程update
        1个线程select，另1个线程delete

        1个线程insert，另1个线程insert
        1个线程insert，另1个线程update
        1个线程insert，另1个线程delete

        1个线程update，另1个线程update
        1个线程update，另1个线程delete

        1个线程delete，另1个线程delete
    3.在不考虑效率的情况下：保持严格一致性的策略：读请求和写请求串行化，串到一个内存队列里去【不推荐】
    4.最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。
        4.1 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
        4.2 更新的时候，先更新数据库，然后再删除缓存。

        自己的话理解：读的线程，先读缓存, 再读db, db读到后写入缓存
                     update/insert/delete的线程，先update/insert/delete数据库，再删除缓存！注意这里是删除，而不是更新
    5.核心关键字：核心是lazy计算的思想
        5.1 读请求和写请求串行化，串到一个内存队列
        5.2 先更新数据库，然后再删除缓存
        5.3 用到缓存才去算缓存
        5.4 数据的唯一标识，串行，多个更新缓存请求串在一起是没意义的
        5.5 jvm队列，读请求的长时阻塞
        5.6 加机器，减少内存队列更新操作积压
        5.7 通过 Nginx 服务器路由到相同的服务实例上.对同一个商品的读写请求，全部路由到同一台机器上。可以自己去做服务间的按照某个请求参数的 hash 路由，也可以用 Nginx 的 hash 路由功能等等

2.分析不一致的原因：这是多线程并发的问题！！！
    1.最初级的缓存不一致问题及解决方案：有更新操作，先删除缓存,再修改db,再删除缓存
        问题：先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。
        解决思路：先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。
    2.比较复杂的数据不一致问题分析：
        问题：数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了...
              为什么上亿流量高并发场景下，缓存会出现这个问题？
          　　只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就 1 万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就可能会出现上述的数据库+缓存不一致的情况。

3.最终版：
最初级的缓存不一致问题及解决方案：
采用 cache aside pattern 并发更新操作的时候可以先删除缓存，然后更新数据库。
此方案下的更新操作情况：
    删除缓存失败，那么不会去执行update操作。
    删除缓存成功，update失败，读请求还是会将旧值写回到redis中。
    删除缓存成功，update成功，读请求会将新值写回到redis中。


复杂情况的解决办法：update请求和read请求都放入队列执行
　　一个update操作，在删除缓存成功，但update操作未提交的情况下，读请求会读取数据库中旧的值，至此缓存中是旧值，update后的数据库是新值，这种情况就应该采用异步读写请求队列去解决，简单言之，update请求入队列，读请求入队列，update操作未执行完之前，读操作被阻塞，但是读操作需要while循环 一段时间，因为一旦当前操作的读请求之前还有一个读请求在队列中，很可能前一个读请求已经将update后的新值已经读取到redis当中了。
　　一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统不是严格要求 “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：读请求和写请求串行化，串到一个内存队列里去。
　　串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。


4.缓存和数据库一致性解决方案
1.第一种方案：采用延时双删策略
在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。
伪代码如下
public void write( String key, Object data )
{
    redis.delKey( key );
    db.updateData( data );
    Thread.sleep( 500 );
    redis.delKey( key );
}
2.具体的步骤就是：
    先删除缓存
    再写数据库
    休眠500毫秒
    再次删除缓存
那么，这个500毫秒怎么确定的，具体该休眠多久呢？
需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。
当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。
3.设置缓存过期时间
　　从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。
4.该方案的弊端
　　结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。
    改进：提供一个保障的重试机制即可：一个消息队列存储删除失败的key,重试删除缓存key


2、第二种方案：异步更新缓存(基于订阅binlog的同步机制)
1.技术整体思路：
MySQL binlog增量订阅消费+消息队列+增量数据更新到redis
    读Redis：热数据基本都在Redis
    写MySQL:增删改都是操作MySQL
    更新Redis数据：MySQ的数据操作binlog，来更新到Redis
2.Redis更新
(1）数据操作主要分为两大块：
    一个是全量(将全部数据一次写入到redis)
    一个是增量（实时更新）
这里说的是增量,指的是mysql的update、insert、delate变更数据。
(2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。
　　这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。
　　其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。
　　这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。
　　当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis!
    改进：提供一个保障的重试机制即可：一个消息队列存储删除失败的key,重试删除缓存key

最终总结：redis和db的数据一致性理论上是不可能，如果真的对数据有强一致性的要求，就不应该放缓存里！！


